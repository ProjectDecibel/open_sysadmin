// error-chain begin
#![recursion_limit = "1024"]

#[macro_use]
extern crate error_chain;

pub mod error_chain_generated_errors {
    extern crate protobuf;
    use std;
    use protobuf::ProtobufError;
    error_chain! {
        types {
            Error, ErrorKind, ResultExt, Result;
        }

        foreign_links {
            ProtobufError(ProtobufError);
            Io(std::io::Error);

        }

        errors {
            SysadminConnectionError(t: String) {
                description("failed during connection attempt")
                display("Network Error: {:?}", t)
            }
            SysadminProtocolError(t: String) {
                description("Error during serialization")
                display("Sysadmin Protocol Error: {:?}", t)
            }
        }
    }
}
pub use error_chain_generated_errors::*;
//  error-chain end

extern crate protobuf;
extern crate bufstream;
extern crate byteorder;
extern crate bytes;
pub mod sysadminctl;

use std::vec::Vec;
use std::string::String;
use std::convert::{Into, From};
use std::time::Duration;
use std::net::{TcpStream, ToSocketAddrs};

use protobuf::Message;
use byteorder::{WriteBytesExt, LittleEndian};
use protobuf::repeated::RepeatedField;

// I don't see a real reason re-impliment this.
pub use sysadminctl::StatusCode;

/// SysAdminClient manages the connection and provides methods
/// for sending specific commands. Each command returns a response in
/// the form of a struct specific to that command.
/// E.g. "SysAdminClient.get" returns "GetResponse"
///
/// Note that the response structs used by the sysadmin lib are a close,
/// but not exact, mappings of the protobut defined responses.
/// For example the "id" and "status" from Response" are merged into
/// "[Get|Set|Whatever]Response" structs.
/// Errors are returned as error-chain errors.

/// Note the "Result" being returned is a type alias generated by error-chain for:
///     type Result<T> = Result<T, Error>;
/// [`error_chain Result`]:
/// https://docs.rs/error-chain/0.11.0/error_chain/example_generated/type.Result.html
/// [`error_chain Error`]:
/// https://docs.rs/error-chain/0.11.0/error_chain/example_generated/struct.Error.html
pub struct SysAdminClient {
    timeout: Duration,
    xid: u32,
    id: u32,
    stream: Option<TcpStream>,
}

impl SysAdminClient {
    pub fn new(timeout: Duration, xid: u32, id: u32) -> SysAdminClient {
        SysAdminClient {
            timeout: timeout,
            xid: xid,
            id: id,
            stream: None,
        }
    }

    /// Init the connection. You can call this method again to init
    /// a new connection.
    /// "address" will become a SocketAddr using the trait
    /// `[ToSocketAddrs]`: https://doc.rust-lang.org/std/net/trait.ToSocketAddrs.html
    pub fn connect<A: ToSocketAddrs>(&mut self, address: A) -> Result<()> {
        let stream = TcpStream::connect(address).chain_err(|| {
            ErrorKind::SysadminConnectionError("Could not connect to Sysadmin".to_string())
        })?;
        stream
            .set_write_timeout(Some(self.timeout.clone()))
            .chain_err(|| {
                ErrorKind::SysadminConnectionError("Error setting write timeout".to_string())
            })?;
        stream
            .set_read_timeout(Some(self.timeout.clone()))
            .chain_err(|| {
                ErrorKind::SysadminConnectionError("Error setting read timeout".to_string())
            })?;
        self.stream = Some(stream);

        Ok(())
    }

    /// Makes the Command which will wrap the payload (e.g. Set or Commit)
    /// xid and id are inserted automatically.
    fn make_command(&self) -> sysadminctl::Command {
        let mut cmd = sysadminctl::Command::new();
        cmd.set_xid(self.xid);
        cmd.set_id(self.id);
        cmd
    }

    /// send the command via tcp and get response
    fn send(&mut self, command: sysadminctl::Command) -> Result<sysadminctl::Response> {
        if self.stream.is_none() {
            bail!(ErrorKind::SysadminConnectionError(
                "Command issued before connection was init".to_string()))
        }
        assert!(command.is_initialized() == true);
        use std::io::Write;


        let size = command.compute_size();
        let bytes = command.write_to_bytes()?;
        assert!(size == bytes.len() as u32);

        // get BigEndian vec from u32
        let mut wtr = vec![];
        wtr.write_u32::<LittleEndian>(size).unwrap();

        {
            // write to socket
            let stream = self.stream.as_mut().unwrap();
            stream.write_all(&wtr)?;
            stream.write_all(&bytes)?;
            stream.flush()?;
        }

        let mut stream = self.stream.as_mut().unwrap();
        // receive response
        let mut cis = protobuf::CodedInputStream::new(&mut stream);
        let resp_size = cis.read_raw_little_endian32().chain_err(|| {
            ErrorKind::SysadminProtocolError("Error reading message size".to_string())
        })?;
        let response_bytes = cis.read_raw_bytes(resp_size).chain_err(|| {
            ErrorKind::SysadminProtocolError("Error reading response from Sysadmin".to_string())
        })?;
        let resp = protobuf::parse_from_bytes::<sysadminctl::Response>(&response_bytes)
            .chain_err(|| {
                ErrorKind::SysadminProtocolError("Error parsing response from Sysadmin".to_string())
            })?;
        Ok(resp)
    }

    /// change xid
    #[allow(dead_code)]
    pub fn set_xid(mut self, xid: u32) -> Self {
        self.xid = xid;
        self
    }

    /// change id
    #[allow(dead_code)]
    pub fn set_id(mut self, id: u32) -> Self {
        self.id = id;
        self
    }

    /// change xid
    #[allow(dead_code)]
    pub fn get_xid(&self) -> u32 {
        self.xid
    }

    /// change id
    #[allow(dead_code)]
    pub fn get_id(&self) -> u32 {
        self.id
    }

    /// Wraps any payload type in a Command and requests it via tcp
    fn request<T: Payload>(&mut self, msg: T) -> Result<sysadminctl::Response> {
        let mut cmd = self.make_command();
        msg.set_payload(&mut cmd);
        self.send(cmd)
    }

    /// send set command and receive SetResponse
    pub fn set<T: Into<SysadminValue>>(&mut self, key: String, value: T) -> Result<SetResponse> {
        let set = Set {
            key: key,
            value: value,
        };
        let resp = self.request(set.into_buf())?;
        Ok(SetResponse::from(resp))
    }

    /// get command and receive GetResponse
    pub fn get(&mut self, key: String) -> Result<GetResponse> {
        let get = Get { key: key };
        let resp = self.request(get.into_buf())?;
        Ok(GetResponse::from(resp))

    }

    /// send commit command and receive CommitResponse
    pub fn commit(&mut self, commit_config: Option<CommitConfig>) -> Result<CommitResponse> {
        let commit = Commit { config: commit_config };
        let resp = self.request(commit.into_buf())?;
        Ok(CommitResponse::from(resp))
    }
}

// TODO: implement Drop
// TODO: implement FireHooks
// TODO: implement EraseKey
// TODO: implement Rollback
// TODO: implement Reset
// TODO: implement DumpHooks
// TODO: implement TriggerHook
// TODO: implement Blame
// TODO: implement InFlight

/// message MappedField {
///     required string key = 1;
///     optional ConfigValue value = 2;
/// }
#[allow(dead_code, non_camel_case_types)]
#[derive(Debug, Clone, PartialEq)]
pub struct kvs {
    pub key: String,
    pub value: Option<SysadminValue>,
}

impl From<sysadminctl::MappedField> for kvs {
    fn from(mut m: sysadminctl::MappedField) -> kvs {
        let value = {
            if m.has_value() {
                Some(SysadminValue::from(m.take_value()))
            } else {
                None
            }
        };
        kvs {
            key: m.take_key(),
            value: value,
        }
    }
}

/// message GetResponse {
///     repeated MappedField kvs = 1;
/// }
#[allow(dead_code)]
#[derive(Debug, Clone, PartialEq)]
pub struct GetResponse {
    pub id: u32,
    pub status: StatusCode,
    pub kvs: Vec<kvs>,
}

impl From<sysadminctl::Response> for GetResponse {
    fn from(mut r: sysadminctl::Response) -> GetResponse {

        let mut get_resp = r.take_get();
        let ctl_vec = get_resp.take_kvs().to_vec();
        let mut kvs_vec: Vec<kvs> = Vec::new();
        ctl_vec.into_iter().for_each(|a| kvs_vec.push(kvs::from(a)));

        GetResponse {
            id: r.get_id(),
            status: r.get_status(),
            kvs: kvs_vec,
        }
    }
}


#[allow(dead_code)]
#[derive(Debug, Clone, PartialEq)]
pub struct SetResponse {
    pub id: u32,
    pub status: StatusCode,
}

impl From<sysadminctl::Response> for SetResponse {
    fn from(r: sysadminctl::Response) -> SetResponse {
        SetResponse {
            id: r.get_id(),
            status: r.get_status(),
        }
    }
}

/// message CommitResponse {
///     required uint32 commit_id = 1;
/// }
#[allow(dead_code)]
#[derive(Debug, Clone, PartialEq)]
pub struct CommitResponse {
    pub id: u32,
    pub status: StatusCode,
    pub commit_id: Option<u32>,
}

impl From<sysadminctl::Response> for CommitResponse {
    fn from(response: sysadminctl::Response) -> CommitResponse {
        let commit_resp = response.get_commit();
        let cid = {
            if commit_resp.has_commit_id() {
                Some(commit_resp.get_commit_id())
            } else {
                None
            }
        };

        CommitResponse {
            id: response.get_id(),
            status: response.get_status(),
            commit_id: cid,
        }
    }
}


#[derive(Debug, Clone, PartialEq)]
struct Get {
    key: String,
}

impl Get {
    fn into_buf(self) -> sysadminctl::Get {
        let mut get = sysadminctl::Get::new();
        get.set_key(self.key);
        get
    }
}

#[derive(Debug, Clone, PartialEq)]
struct Set<T: Into<SysadminValue>> {
    key: String,
    value: T,
}

impl<T> Set<T>
where
    T: Into<SysadminValue>,
{
    fn into_buf(self) -> sysadminctl::Set {
        let mut set = sysadminctl::Set::new();
        set.set_key(self.key);
        let sv: SysadminValue = self.value.into();
        let cv: sysadminctl::ConfigValue = sysadminctl::ConfigValue::from(sv);
        set.set_value(cv);
        set
    }
}

struct Commit {
    config: Option<CommitConfig>,
}

impl Commit {
    fn into_buf(self) -> sysadminctl::Commit {
        let mut commit = sysadminctl::Commit::new();
        if let Some(config) = self.config {
            let commitconfig = sysadminctl::CommitConfig::from(config);
            commit.set_config(commitconfig);
        }
        commit
    }
}

#[allow(non_camel_case_types)]
#[derive(PartialEq, Eq, Debug)]
pub enum CommitConfig {
    DEFAULT = 0,
    TEMPLATE_ONLY = 1,
    NO_HOOKS = 3,
}
impl From<CommitConfig> for sysadminctl::CommitConfig {
    fn from(c: CommitConfig) -> sysadminctl::CommitConfig {
        match c {
            CommitConfig::DEFAULT => sysadminctl::CommitConfig::DEFAULT,
            CommitConfig::TEMPLATE_ONLY => sysadminctl::CommitConfig::TEMPLATE_ONLY,
            CommitConfig::NO_HOOKS => sysadminctl::CommitConfig::NO_HOOKS,
        }
    }
}


#[derive(Clone, Debug, PartialEq)]
pub enum SysadminValue {
    Int32(i32),
    Strval(String),
    Bool(bool),
    Int32List(Vec<i32>),
    BoolList(Vec<bool>),
    StrvalList(Vec<String>),
}

impl From<i32> for SysadminValue {
    fn from(v: i32) -> Self {
        SysadminValue::Int32(v)
    }
}

impl From<String> for SysadminValue {
    fn from(v: String) -> Self {
        SysadminValue::Strval(v)
    }
}

impl From<bool> for SysadminValue {
    fn from(v: bool) -> Self {
        SysadminValue::Bool(v)
    }
}
impl From<Vec<i32>> for SysadminValue {
    fn from(v: Vec<i32>) -> Self {
        SysadminValue::Int32List(v)
    }
}
impl From<Vec<bool>> for SysadminValue {
    fn from(v: Vec<bool>) -> Self {
        SysadminValue::BoolList(v)
    }
}
impl From<Vec<String>> for SysadminValue {
    fn from(v: Vec<String>) -> Self {
        SysadminValue::StrvalList(v)

    }
}

impl From<SysadminValue> for sysadminctl::ConfigValue {
    fn from(v: SysadminValue) -> sysadminctl::ConfigValue {
        let mut cv = sysadminctl::ConfigValue::new();
        match v {
            SysadminValue::Int32(x) => cv.set_int32val(x),
            SysadminValue::Strval(x) => cv.set_strval(x),
            SysadminValue::Bool(x) => cv.set_boolval(x),
            SysadminValue::Int32List(x) => {
                let mut list = sysadminctl::Int32List::new();
                list.set_list(x);
                cv.set_int32list(list);
            }
            SysadminValue::BoolList(x) => {
                let mut list = sysadminctl::BoolList::new();
                list.set_list(x);
                cv.set_boollist(list);
            }
            SysadminValue::StrvalList(x) => {
                let mut list = sysadminctl::StringList::new();
                list.set_list(RepeatedField::from_vec(x));
                cv.set_stringlist(list);
            }
        }
        cv
    }
}

impl From<sysadminctl::ConfigValue> for SysadminValue {
    fn from(mut cv: sysadminctl::ConfigValue) -> SysadminValue {
        let sysadminvalue = match cv {
            ref mut v if v.has_int32val() => SysadminValue::Int32(v.get_int32val()),
            ref mut v if v.has_strval() => SysadminValue::Strval(v.take_strval()),
            ref mut v if v.has_boolval() => SysadminValue::Bool(v.get_boolval()),
            ref mut v if v.has_int32list() => {
                let mut list = v.take_int32list();
                SysadminValue::Int32List(list.take_list())
            }
            ref mut v if v.has_boollist() => {
                let mut list = v.take_boollist();
                SysadminValue::BoolList(list.take_list())
            }
            ref mut v if v.has_stringlist() => {
                let repeating = v.take_stringlist().take_list();
                let list = RepeatedField::into_vec(repeating);
                SysadminValue::StrvalList(list)
            }
            // TODO send an error back instead
            ref mut v => {
                panic!(format!(
                    "{} {} {:?}",
                    "Error converting to SysadminValue",
                    "from sysadminctl::ConfigValue:",
                    v
                ))
            }
        };
        sysadminvalue
    }
}

pub trait Payload {
    /// set_payload adds the payload to a command
    /// using the proper command for each payload type
    fn set_payload(self, command: &mut sysadminctl::Command);
}


impl Payload for sysadminctl::Set {
    fn set_payload(self, command: &mut sysadminctl::Command) {
        command.set_set(self);
    }
}

impl Payload for sysadminctl::Get {
    fn set_payload(self, command: &mut sysadminctl::Command) {
        command.set_get(self);
    }
}

impl Payload for sysadminctl::Commit {
    fn set_payload(self, command: &mut sysadminctl::Command) {
        command.set_commit(self);
    }
}

impl Payload for sysadminctl::Drop {
    fn set_payload(self, command: &mut sysadminctl::Command) {
        command.set_drop(self);
    }
}

impl Payload for sysadminctl::FireHooks {
    fn set_payload(self, command: &mut sysadminctl::Command) {
        command.set_firehooks(self);
    }
}

impl Payload for sysadminctl::EraseKey {
    fn set_payload(self, command: &mut sysadminctl::Command) {
        command.set_erase(self);
    }
}

impl Payload for sysadminctl::Rollback {
    fn set_payload(self, command: &mut sysadminctl::Command) {
        command.set_rollback(self);
    }
}

impl Payload for sysadminctl::Reset {
    fn set_payload(self, command: &mut sysadminctl::Command) {
        command.set_reset(self);
    }
}

impl Payload for sysadminctl::DumpHooks {
    fn set_payload(self, command: &mut sysadminctl::Command) {
        command.set_dump(self);
    }
}

impl Payload for sysadminctl::TriggerHook {
    fn set_payload(self, command: &mut sysadminctl::Command) {
        command.set_trigger(self);
    }
}

impl Payload for sysadminctl::Blame {
    fn set_payload(self, command: &mut sysadminctl::Command) {
        command.set_blame(self);
    }
}

impl Payload for sysadminctl::InFlight {
    fn set_payload(self, command: &mut sysadminctl::Command) {
        command.set_inflight(self);
    }
}



#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_str() {
        test_sysadminvalue(123_i32);
    }
    #[test]
    fn test_i32() {
        test_sysadminvalue(String::from("123"));
    }
    #[test]
    fn test_bool() {
        test_sysadminvalue(true);
    }
    #[test]
    fn test_i32_list() {
        test_sysadminvalue(vec![1_i32, 2_i32, 3_i32]);
    }
    #[test]
    fn test_str_list() {
        test_sysadminvalue(vec![
            String::from("1"),
            String::from("2"),
            String::from("3"),
        ]);
    }
    #[test]
    fn test_bool_list() {
        test_sysadminvalue(vec![true, false, true]);
    }


    fn test_sysadminvalue<T: Into<SysadminValue>>(variant: T) {
        let sysadminvalue: SysadminValue = variant.into();
        let sv_for_convert = sysadminvalue.clone();
        let configvalue = sysadminctl::ConfigValue::from(sv_for_convert);
        let restored_sv = SysadminValue::from(configvalue);
        assert_eq!(sysadminvalue, restored_sv);
    }

    #[test]
    fn test_set_str() {
        test_set_to_sysadminctl(123_i32);
    }
    #[test]
    fn test_set_i32() {
        test_set_to_sysadminctl(String::from("123"));
    }
    #[test]
    fn test_set_bool() {
        test_set_to_sysadminctl(true);
    }
    #[test]
    fn test_set_i32_list() {
        test_set_to_sysadminctl(vec![1_i32, 2_i32, 3_i32]);
    }
    #[test]
    fn test_set_str_list() {
        test_set_to_sysadminctl(vec![
            String::from("1"),
            String::from("2"),
            String::from("3"),
        ]);
    }
    #[test]
    fn test_set_bool_list() {
        test_set_to_sysadminctl(vec![true, false, true]);
    }


    fn test_set_to_sysadminctl<T: Into<SysadminValue>>(v: T) {
        use std::clone::Clone;
        let k = String::from("key");
        let sysadminvalue: SysadminValue = v.into();
        let set = Set {
            key: k.clone(),
            value: SysadminValue::from(sysadminvalue.clone()),
        };
        let mut buf: sysadminctl::Set = set.into_buf();
        assert_eq!(buf.is_initialized(), true);
        let buf_val = buf.take_value();
        // see if configvalue matches
        assert_eq!(buf_val, sysadminctl::ConfigValue::from(sysadminvalue));
    }


}
